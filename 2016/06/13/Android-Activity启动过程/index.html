
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="baidu_union_verify" content="d1952c66cf48912e21c18c7c581f382a">
  <meta name="360-site-verification" content="67fbcc5a67f4c65c057315b28fa0b2c8" />
<meta name="google-site-verification" content="2GzxQ0VtXwTSUdmGm6DzcmhTzM_I9QmzCb_pzpMzD88" />
  
    <title>如何实现一个缓存系统 | Glory Seeker by HaioLv</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="haiolv">
    
    <meta name="description" content="Android Activity的启动过程Android进程创建应用程序的入口一般来说，我们都认为是Launcher Activity的onCreate方法，但追求根本，Android应用程序的入口应该是ActivityThread的main方法。
ActivityThread类：该类为应用程序的主">
    
    
    
    
    <link rel="alternate" href="atom.xml" title="Glory Seeker by HaioLv" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css">
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='391982416296a0d54221f59fe35250d4';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
     
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Glory Seeker by HaioLv">Glory Seeker by HaioLv</a></h1>
				<a class="blog-motto">Make progress step by step everyday！</a>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/categories/随笔/">随笔</a></li>
					
						<li><a href="/categories/写作/">写作</a></li>
					
						<li><a href="/categories/阅读/">阅读</a></li>
					
						<li><a href="/categories/学习/">学习</a></li>
					
						<li><a href="/categories/编程/">编程</a></li>
					
					<li>
					
                                            <form class="search" action=http://zhannei.baidu.com/cse/search target="_blank">
                                            <label>Search</label>
                                        <input name="s" type="hidden" value= null ><input type="text" name="q" size="30" placeholder="搜索"><br>
					
					</li>
				</ul>
                            </nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/13/Android-Activity启动过程/" title="如何实现一个缓存系统" itemprop="url">如何实现一个缓存系统</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://plus.google.com/106056846526324800000?rel=author" title="haiolv" target="_blank" itemprop="author">haiolv</a>
    </p>
  <p class="article-time">
    <time datetime="2016-06-13T03:24:36.000Z" itemprop="datePublished">2016-06-13</time>
    更新日期:<time datetime="2016-06-13T09:08:15.990Z" itemprop="dateModified">2016-06-13</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Activity的启动过程"><span class="toc-number">1.</span> <span class="toc-text">Android Activity的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android进程创建"><span class="toc-number">1.1.</span> <span class="toc-text">Android进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity启动"><span class="toc-number">1.2.</span> <span class="toc-text">Activity启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Instrumentation"><span class="toc-number">1.2.1.</span> <span class="toc-text">Instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityManagerService"><span class="toc-number">1.2.2.</span> <span class="toc-text">ActivityManagerService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityStack"><span class="toc-number">1.2.3.</span> <span class="toc-text">ActivityStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessRecord—记录了一个进程的相关信息。"><span class="toc-number">1.2.4.</span> <span class="toc-text">ProcessRecord—记录了一个进程的相关信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IApplicationThread接口AMS-gt-Application"><span class="toc-number">1.2.5.</span> <span class="toc-text">IApplicationThread接口AMS->Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于Activity启动的流程图"><span class="toc-number">1.2.6.</span> <span class="toc-text">关于Activity启动的流程图</span></a></li></ol></li></ol></li></ol>
		</div>
		
		<h2 id="Android-Activity的启动过程"><a href="#Android-Activity的启动过程" class="headerlink" title="Android Activity的启动过程"></a>Android Activity的启动过程</h2><h3 id="Android进程创建"><a href="#Android进程创建" class="headerlink" title="Android进程创建"></a>Android进程创建</h3><p>应用程序的入口一般来说，我们都认为是Launcher Activity的onCreate方法，但追求根本，Android应用程序的入口应该是ActivityThread的main方法。</p>
<p><strong>ActivityThread类</strong>：该类为应用程序的主线程类，所有的应用程序都有且仅有一个ActivityThread类，程序的入口为该类中的static main()函数。</p>
<p><strong>Activity类</strong>：该类为APK（AndroidPackage，是一种通过AndroidSDK编译的工程打包成的安装程序文件）程序的一个最小运行单元，一个APK程序中可以包含多个Activity对象，ActivityThread主类会根据用户操作选择运行哪个Activity对象。</p>
<p><strong>ActivityManagerService类</strong>：简称AMS，它的作用是管理所有应用程序中的Activity。</p>
<pre><code>//ActivityThread的main方法

public static void main(String[] args) {
    SamplingProfilerIntegration.start();

    // CloseGuard defaults to true and can be quite spammy.  We
    // disable it here, but selectively enable it later (via
    // StrictMode) on debug builds, but using DropBox, not logs.
    CloseGuard.setEnabled(false);

    Environment.initForCurrentUser();

    // Set the reporter for event logging in libcore
    EventLogger.setReporter(new EventLoggingReporter());

    Security.addProvider(new AndroidKeyStoreProvider());

    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);

    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    AsyncTask.init();

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
    }

    Looper.loop();

    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}
</code></pre><p>如上所示，其main方法中 初始化了并构建了主线程Looper。</p>
<p>至于，ActivityThread在是什么时候被调用，如下：</p>
<pre><code>// 在ActivityManagerService.java中：  

Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,  
                app.processName, uid, uid, gids, debugFlags,  
                app.info.targetSdkVersion, null, null);  
</code></pre><p>对于应用程序的创建，最终通过 AMS 调度Process.start()静态方法来启动新程序,实际上最终将调用其main函数.</p>
<p>那么，应用程序是通过怎样的一个方式通知创建其进程的？</p>
<p>应用程序是用过向socket服务端写数据，把创建进程的请求通过socket通讯方式来让framework的进程孵化类zygote创建新进程。Zygote进程、SystemServer进程、各APK进程和创建进程的socket服务端/客户端的关系如下图所示：</p>
<p><img src="http://i.imgur.com/F1FDTyz.png" alt="zygote"></p>
<blockquote>
<p>Android进程孵化环境</p>
<p>当Android内核启动后，此时系统的状态和普通的Linux系统基本相同，通过配置Android中的init.rc文件，可以指定内核启动后都要执行什么程序，而在此配置文件中指定的之后所要启动的程序才是Android系统和普通Linux应用系统的区别。Android系统里init.rc中所启动的一个重要进程被称作zygote进程，也称为“种子进程”，从进程的角度来看，种子进程仅仅是一个Linux进程而已，它和一个只包含main()函数的C程序所产生的进程是同一个级别，但种子进程里面所运行的程序基本上就是Android内核的精华所在，其内部主要完成了两件事情。第一件事情是装载了一段程序代码，这些代码都是用C语言写的，这段代码的作用只是为了能够执行Java编译器编译出的字节码，功能类似Java虚拟机，在Android中称为Dalvik虚拟机。第二件事情必须基于第一件事情之后，即当Dalvik虚拟机代码初始化完成后，开始执行ZygoteInit.java类中的main()函数。ZygoteInit.java这个Jar包的目录位置信息也是在init.rc中进行配置的，是使用一个“zygote”标志符，Dalvik虚拟机就会从init.rc配置项的键值对中得到ZygoteInit类所在的Jar包，而这个Jar包正是Android的另一个核心–framework.jar。</p>
<p>接下ZygoteInit类中main()函数所做的事情和Linux本身就没多大关系了，该main()函数中才刚刚开始启动Android的核心功能。首先加载一些类文件，这些类将作为以后所有其它Apk程序共享的类，接着，会创建一个Socket服务端，该服务端将用于通过Socket启动新进程。zygote进程被称为“种子”进程的原因就是，当其内部的Socket服务端收到启动新的Apk进程的请求时，会使用Linux的一个系统调用folk()函数从自身复制出一个新的进程，新进程和Zygote进程将共享已经装载的类，这些类都是在framework.jar中定义的。</p>
</blockquote>
<pre><code>// ZygoteInit.java的main函数如下：  
public static void main(String argv[]) {  
    try {  
        …  
        registerZygoteSocket(); // 注册一个socket server来监听zygote命令  
        preloadClasses();//预加载java class  
        preloadResources();//预加载资源文件  
        …  
        gc();/*初始化GC垃圾回收机制*/  
        if (argv[1].equals(&quot;true&quot;)) {  

            /* 通过main中传递过来的第二个参数startsystemserver=”true” 启动systemserver, 在startSystemServer()中会fork一个新的进程命名为system_server， 执行的是com.android.server包中的SystemServer.java文件中的main函数*/  

            startSystemServer();
             ///*************  
        } else if(…)   
        …

        if (ZYGOTE_FORK_MODE) {  
             runForkMode();      /*将进入Zygote的子进程*/  
        } else {  
             runSelectLoopMode();/* Zygote进程进入无限循环，不再返回。接下来的zygote将会作为一个孵化服务进程来运行。*/  
        }  
        closeServerSocket();  
    }  
    …  
}  
</code></pre><p>简而言之：android程序进程创建的整个流程如下</p>
<ul>
<li>Application层的程序发起创建应用程序的命令；</li>
<li>Ams调度框架通过framework发起socket通讯通知新进程创建；</li>
<li>zygote孵化进程接收socket信息并调用内核创建新进程；</li>
</ul>
<p>也就是说 ，最终是通过zygote fork一个应用进程。</p>
<p>综上所述，创建程序新进程的任务最关键就是zygote进程。Zygote进程起到一个承上启下的作用。对于framework，zygote进程接收上层应用通过socket发送过来的新进程创建命令，对于kernel而言，zygote进程主要调用了内核的fork()系统调用来进行新进程的创建，所以zygote在android系统中扮演一个非常重要的角色，是新进程创建的一个孵化器。</p>
<p><img src="http://i.imgur.com/mDrhXtj.png" alt="process-flow"></p>
<p>Reference: </p>
<ul>
<li><a href="https://android.googlesource.com/" title="https://android.googlesource.com/" target="_blank" rel="external">Android 源码 repo</a></li>
<li><a href="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" title="https://www.google.com.hk/#q=Android+Anatomy+and+Physiology" target="_blank" rel="external">Android Anatomy and Physiology</a></li>
<li>柯元旦《android内核剖析》电子工业出版社</li>
</ul>
<h3 id="Activity启动"><a href="#Activity启动" class="headerlink" title="Activity启动"></a>Activity启动</h3><p>Android应用程序启动过程，即为LauncherActivity的启动过程，Android应用程序从Launcher启动 程序 流程如下所示：</p>
<pre><code>/***************************************************************** 
  * Launcher通过Binder告诉ActivityManagerService， 
  * 它将要启动一个新的Activity； 
  ****************************************************************/  
 Launcher.startActivitySafely-&gt;    
 Launcher.startActivity-&gt;

     //要求在新的Task中启动此Activity    
     //intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)    
     Activity.startActivity-&gt;    
     Activity.startActivityForResult-&gt;    
     Instrumentation.execStartActivity-&gt;    

     // ActivityManagerNative.getDefault()返回AMS Proxy接口    
     ActivityManagerNative.getDefault().startActivity-&gt;    
     ActivityManagerProxy.startActivity-&gt;    

        ActivityManagerService.startActivity-&gt; (AMS)    
        ActivityManagerService.startActivityAsUser-&gt;     

         ActivityStack.startActivityMayWait-&gt;    
        ActivityStack.resolveActivity(获取ActivityInfo)    
           //aInfo.name为main Activity,如：com.my.test.MainActivity    
           //aInfo.applicationInfo.packageName为包名，如com.my.test    
         ActivityStack.startActivityLocked-&gt;    
           //ProcessRecord callerApp; 调用者即Launcher信息    
           //ActivityRecord sourceRecord; Launcher Activity相关信息    
           //ActivityRecord r=new ActivityRecord(...)，将要创建的Activity相关信息      
         ActivityStack.startActivityUncheckedLocked-&gt;    
          //Activity启动方式：ActivityInfo.LAUNCH_MULTIPLE/LAUNCH_SINGLE_INSTANCE/    
          //             ActivityInfo.LAUNCH_SINGLE_TASK/LAUNCH_SINGLE_TOP)    
          // 创建一个新的task,即TaskRecord,并保存在ActivityRecord.task中    
          //r.setTask(new TaskRecord(mService.mCurTask, r.info, intent), null, true)    
          // 把新创建的Activity放在栈顶       
          ActivityStack.startActivityLocked-&gt;    
          ActivityStack.resumeTopActivityLocked-&gt;    
          ActivityStack.startPausingLocked (使Launcher进入Paused状态)-&gt;      

  /***************************************************************** 
   * AMS通过Binder通知Launcher进入Paused状态 
   ****************************************************************/  
   ApplicationThreadProxy.schedulePauseActivity-&gt;     
   //private class ApplicationThread extends ApplicationThreadNative    
   ApplicationThread.schedulePauseActivity-&gt;    

   ActivityThread.queueOrSendMessage-&gt;    

    // 调用Activity.onUserLeaveHint    
    // 调用Activity.onPause    
    // 通知activity manager我进入了pause状态    
    ActivityThread.handlePauseActivity-&gt;    

    /***************************************************************** 
     * Launcher通过Binder告诉AMS，它已经进入Paused状态 
     ****************************************************************/  
    ActivityManagerProxy.activityPaused-&gt;    
    ActivityManagerService.activityPaused-&gt;    
    ActivityStack.activityPaused-&gt;(把Activity状态修改为PAUSED)    
    ActivityStack.completePauseLocked-&gt;    

    // 参数为代表Launcher这个Activity的ActivityRecord    
    // 使用栈顶的Activity进入RESUME状态    
    ActivityStack.resumeTopActivityLokced-&gt;    
    //topRunningActivityLocked将刚创建的放于栈顶的activity取回来    
    // 即在ActivityStack.startActivityUncheckedLocked中创建的    

    /***************************************************************** 
     * AMS创建一个新的进程，用来启动一个ActivityThread实例， 
     * 即将要启动的Activity就是在这个ActivityThread实例中运行 
     ****************************************************************/  
    ActivityStack.startSpecificActivityLocked-&gt;    

     // 创建对应的ProcessRecord    
     ActivityManagerService.startProcessLocked-&gt;    

          // 启动一个新的进程    
          // 新的进程会导入android.app.ActivityThread类，并且执行它的main函数,    
          // 即实例化ActivityThread, 每个应用有且仅有一个ActivityThread实例    
          Process.start(&quot;android.app.ActivityThread&quot;,...)-&gt;    

          // 通过zygote机制创建一个新的进程    
          Process.startViaZygote-&gt;    

          // 这个函数在进程中创建一个ActivityThread实例，然后调用    
          // 它的attach函数，接着就进入消息循环    
          ActivityThread.main-&gt;    

      /***************************************************************** 
       * ActivityThread通过Binder将一个ApplicationThread类的Binder对象 
       * 传递给AMS，以便AMS通过此Binder对象来控制Activity整个生命周期 
       ****************************************************************/  
      ActivityThread.attach-&gt;    
      IActivityManager.attachApplication(mAppThread)-&gt;    
      ActivityManagerProxy.attachApplication-&gt;    
      ActivityManagerService.attachApplication-&gt;    

      // 把在ActivityManagerService.startProcessLocked中创建的ProcessRecord取出来    
      ActivityManagerService.attachApplicationLocked-&gt;    

      /***************************************************************** 
       * AMS通过Binder通知ActivityThread一切准备OK,它可以真正启动新的Activity了 
       ****************************************************************/              
      // 真正启动Activity    
      ActivityStack.realStartActivityLocked-&gt;    
      ApplicationThreadProxy.scheduleLaunchActivity-&gt;    
      ApplicationThread.scheduleLaunchActivity-&gt;    
      ActivityThread.handleLaunchActivity-&gt;    
        // 加载新的Activity类，并执行它的onCreate    
        ActivityThread.performLaunchActivity    
           /*---------------------------------------------
           1) Instrumentation.newActivity: 加载新类，即创建Activity对象；  
           2) ActivityClientRecord.packageInfo.makeApplication：创建Application对象；  
              &lt;LoadedApk.makeApplication&gt;  
           3) Activity.attach(Context context, ActivityThread aThread,  
                 Instrumentation instr, IBinder token, int ident,  
                 Application application, Intent intent, ActivityInfo info,  
                 CharSequence title, Activity parent, String id,  
                 NonConfigurationInstances lastNonConfigurationInstances,  
                 Configuration config)：把Application attach到Activity, 即把Activtiy  
                                        相关信息设置到新创建的Activity中  
           4) Instrumentation.callActivityOnCreate：调用onCreate；
            ---------------------------------------------*/    

        // 使用Activity进入RESUMED状态，并调用onResume    
        ActivityThread.handleResumeActivity    
</code></pre><p>从Activity的启动流程中，我们可以看到几个比较重要的类：</p>
<h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h4><p>顾名思义，仪器仪表，用于在应用程序中进行“测量”和“管理”工作。一个应用程序中只有一个Instrumentation实例对象，且每个Activity都有此对象的引用。Instrumentation将在任何应用程序运行前初始化，可以通过它监测系统与应用程序之间的所有交互，即类似于在系统与应用程序之间安装了个“窃听器”。</p>
<p>当ActivityThread 创建(callActivityOnCreate)、暂停、恢复某个Activity时，通过调用此对象的方法来实现，如：</p>
<p>1) 创建: callActivityOnCreate </p>
<p>2) 暂停: callActivityOnPause</p>
<p>3) 恢复: callActivityOnResume</p>
<h4 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h4><h4 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h4><p>ActivityManagerService使用它来管理系统中所有的Activities的状态，Activities使用stack的方式进行管理。它是真正负责做事的家伙，很勤快的，但外界无人知道！</p>
<h4 id="ProcessRecord—记录了一个进程的相关信息。"><a href="#ProcessRecord—记录了一个进程的相关信息。" class="headerlink" title="ProcessRecord—记录了一个进程的相关信息。"></a>ProcessRecord—记录了一个进程的相关信息。</h4><h4 id="IApplicationThread接口AMS-gt-Application"><a href="#IApplicationThread接口AMS-gt-Application" class="headerlink" title="IApplicationThread接口AMS-&gt;Application"></a>IApplicationThread接口AMS-&gt;Application</h4><p>IApplicationThread为AMS作为客户端访问Application服务器端的Binder接口。当创建Application时，将把此Binder对象传递给AMS，然后AMS把它保存在mProcessNames.ProcessRecord.thread中。当需要通知Application工作时，则调用IApplicationThread中对应的接口函数。</p>
<p><img src="http://i.imgur.com/E67npgC.png" alt="IApplicationThread"></p>
<p>Reference:</p>
<p><a href="http://www.kancloud.cn/digest/androidframeworks/127785" title="http://www.kancloud.cn/digest/androidframeworks/127785" target="_blank" rel="external">http://www.kancloud.cn/digest/androidframeworks/127785</a></p>
<h4 id="关于Activity启动的流程图"><a href="#关于Activity启动的流程图" class="headerlink" title="关于Activity启动的流程图"></a>关于Activity启动的流程图</h4><p><img src="http://i.imgur.com/Vie24ZR.jpg" alt="launcher-flow"></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程/">编程</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://91yang.github.io/2016/06/13/Android-Activity启动过程/" data-title="如何实现一个缓存系统 | Glory Seeker by HaioLv" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/06/13/android-anr分析/"  title="Android ANR 分析">
 <strong>NEXT:</strong><br/> 
 <span>Android ANR 分析
</span>
</a>
</div>

</nav>

	
<section class="comment">
	
	<div class="ds-thread" data-title="如何实现一个缓存系统" data-thread-key="Android-Activity启动过程" data-author-key="haiolv" data-url="http://91yang.github.io/post/Android-Activity启动过程"></div>
	
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Activity的启动过程"><span class="toc-number">1.</span> <span class="toc-text">Android Activity的启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android进程创建"><span class="toc-number">1.1.</span> <span class="toc-text">Android进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity启动"><span class="toc-number">1.2.</span> <span class="toc-text">Activity启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Instrumentation"><span class="toc-number">1.2.1.</span> <span class="toc-text">Instrumentation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityManagerService"><span class="toc-number">1.2.2.</span> <span class="toc-text">ActivityManagerService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityStack"><span class="toc-number">1.2.3.</span> <span class="toc-text">ActivityStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessRecord—记录了一个进程的相关信息。"><span class="toc-number">1.2.4.</span> <span class="toc-text">ProcessRecord—记录了一个进程的相关信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IApplicationThread接口AMS-gt-Application"><span class="toc-number">1.2.5.</span> <span class="toc-text">IApplicationThread接口AMS->Application</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于Activity启动的流程图"><span class="toc-number">1.2.6.</span> <span class="toc-text">关于Activity启动的流程图</span></a></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-logo"></div>		
	
	<div class="social-list" class="clearfix">
		
		
		
		<a href="https://github.com/HaioLv" target="_blank" title="github"></a>
		
		
		
	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/编程/" title="编程">编程<sup>3</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Android/" title="Android">Android<sup>3</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
      <li><a href="http://cstsinghua.github.io/" target="_blank" title="friends">Atypical programmer</a></li>
      <li><a href="http://aso210.github.io/" target="_blank" title="friends">aso210</a></li>
	  <li><a href="http://developer.android.com/" target="_blank" title="coney">Android官网</a></li>
    </ul>
</div>


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Android/" style="font-size: 10px;">Android</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
    
            <p class="copyright"> © 2016 
		
		<a href="http://91yang.github.io" target="_blank" title="haiolv">haiolv</a>
		
            && Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>
            </div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script>
    
        var _bdImg = '4';
    
    window._bd_share_config={
        "common":{
            "bdSnsKey":{

            },
            "bdText":"",
            "bdMini":"2",
            "bdMiniList":[
                "qzone",
                "tsina",
                "weixin",
                "renren",
                "tqq",
                "tieba",
                "douban",
                "sqq",
                "diandian",
                "huaban",
                "youdao",
                "mail",
                "ty",
                "fbook",
                "twi",
                "linkedin",
                "copy",
                "print"
            ],
            "bdPic":"",
            "bdStyle":"0",
            "bdSize":"16"
        },
        "slide":{
            "type":"slide",
            "bdImg":_bdImg,
            "bdPos":"right",
            "bdTop":"350"
        },
        "image":{
            "viewList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ],
            "viewText":"分享：",
            "viewSize":"16"
        },
        "selectShare":{
            "bdContainerClass":null,
            "bdSelectMiniList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ]
        }
    };
    with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>




<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>


  </body>
</html>

